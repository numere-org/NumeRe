#*  _____    __                            ______        
 * |     \  |  |  __ __   _______   ____  |  __  \  ____ 
 * |  |\  \ |  | |  |  | |       \ / __ \ |   ___/ / __ \
 * |  | \  \|  | |  |  | |  Y Y  | | ___/ |     \  | ___/
 * |__|  \_____| |____/  |__|_|__| \____) |__|\__\ \____)
 * ~ ~ ~ ~  Framework fuer Numerische Rechnungen  ~ ~ ~ ~
 * ======================================================
 * | ++ (c) 2016, E. Haenel et al. +++ GNU GPL v 3.0 ++ |
 * ======================================================
 *
 *******************************************************************************
 * Dieses Plugin ist freie Software. Sie können es unter den Bedingungen       *
 * der GNU General Public License, wie von der Free Software Foundation        *
 * veröffentlicht, weitergeben und/oder modifizieren, entweder gemäß Version 3 *
 * der Lizenz, oder (nach Ihrer Option) jeder späteren Version.                *
 * Die Veröffentlichung dieses Scripts erfolgt in der Hoffnung, dass es        *
 * Ihnen von Nutzen sein wird, aber OHNE IRGENDEINE GARANTIE, sogar ohne die   *
 * implizite Garantie der MARKTREIFE oder der VERWENDBARKEIT FÜR EINEN         *
 * BESTIMMTEN ZWECK. Details stehen in der GNU General Public Licence          *
 * Sie sollten ein Exemplar der GNU GPL zusammen mit diesem Script erhalten    *
 * haben. Falls nicht, siehe <http://www.gnu.org/licenses/>.                   *
 *******************************************************************************
 *
 * Dieses Script enthält die Installationsroutine für das Batch-Processing-Plugin,
 * das mittels des Kommandos "install plgn_batch" installiert werden kann. Dieses
 * Plugin bietet die Möglichkeit, zu wiederholende Arbeiten an mehreren Dateien zu
 * automatisieren.
 *#

<install>
	<info>
		-author="Erik Hänel"
		-version="0.3.7"
		-flags=ENABLE_FULL_LOGGING,DISABLE_SCREEN_OUTPUT
		-type=TYPE_PLUGIN
		-name="Batch-Processor"
		-plugincommand="batch"
		-pluginmain=$plugins~batchprocessing~batch_helper(<PARAMSTRING>)
		-plugindesc="Dieses Plugin ermöglicht das automatisierte Verarbeiten mehrerer Dateien. Siehe \"help batch\" für weitere Details."
	<endinfo>

	procedure $plugins~batchprocessing~batch_helper(paramstring = "") :: explicit
		str sParams = to_string(paramstring), sFileScheme = "", sDirectory = "", sEvalCommand = ""
		var sinfit = false, minmax = false, xcol = 1, ycol = 2
		
		## Übergabewerte prüfen
		if (!strlen(sParams))
			throw "Es wurden keine Parameter angegeben."
		endif
		
		if (findparam("scheme", sParams, "="))
			sFileScheme = getopt(sParams, findparam("scheme", sParams, "=")+6)
		endif
		if (findparam("dir", sParams, "="))
			sDirectory = getopt(sParams, findparam("dir", sParams, "=")+3)
		endif
		if (findparam("command", sParams, "="))
			sEvalCommand = getopt(sParams, findparam("command", sParams, "=")+7)
		endif

		#*
		 * Hier könnten noch Built-In Auswertungen eingebunden werden
		 * (Evtl. stats, hist, etc.)
		 *#
		 
		if (sEvalCommand == "sinfit" || substr(sEvalCommand,1,7) == "sinfit(")
			if (substr(sEvalCommand,1,7) == "sinfit(")
				{xcol,ycol} = to_value(substr(sEvalCommand,8,strfnd(")",sEvalCommand)-8))
				(xcol == ycol) ? ycol = ycol + 1 : 0
			endif
			sEvalCommand = "$plugins~batchprocessing~sinfit(fIndex,"+#xcol+","+#ycol+")";
			sinfit = true
			new sinfit()
			delete sinfit() -ignore
			sinfit(#,:) = "Amplitude", "Frequenz", "Phase", "Offset";
		endif
		if (sEvalCommand == "dampedsinfit" || substr(sEvalCommand,1,13) == "dampedsinfit(")
			if (substr(sEvalCommand,1,13) == "dampedsinfit(")
				{xcol,ycol} = to_value(substr(sEvalCommand,14,strfnd(")",sEvalCommand)-14))
				(xcol == ycol) ? ycol = ycol + 1 : 0
			endif
			sEvalCommand = "$plugins~batchprocessing~dampedsinfit(fIndex,"+#xcol+","+#ycol+")";
			sinfit = true
			new sinfit()
			delete sinfit() -ignore
			sinfit(#,:) = "Amplitude", "Zeitkonst", "Frequenz", "Phase", "Offset";
		endif
		if (sEvalCommand == "minmax")
			sEvalCommand = "$plugins~batchprocessing~minmax(fIndex)";
			minmax = true
			new minmax()
			delete minmax() -ignore
			minmax(#,:) = "Minimum", "Maximum";
		endif
		$plugins~batchprocessing~batch(sDirectory, sFileScheme, sEvalCommand)
		if (sinfit)
			"Batch-Processing erfolgreich abgeschlossen.\n" -print
			"Ergebnisse der Anpassungen:" -print
			show sinfit()
			"(Diese Daten sind im Cache \"sinfit()\" abrufbar)" -print
			hline
			return void
		endif
		if (minmax)
			"Batch-Processing erfolgreich abgeschlossen.\n" -print
			"Minima und Maxima:" -print
			show minmax()
			"(Diese Daten sind im Cache \"minmax()\" abrufbar)" -print
			hline
			return void
		endif
				
		"Batch-Processing erfolgreich abgeschlossen." -print
		return void
	endprocedure

	## Sinusfit
	procedure $plugins~batchprocessing~sinfit(fileindex, xcol = 1, ycol = 2) :: explicit private
		var A = (max(data(:,ycol))-min(data(:,ycol)))/2, B = nan, C, D = min(data(:,ycol))+A, x0 = nan, x1 = nan
		if (!cnt(data(:,ycol)))
			throw "Die Spalte "+#ycol+" enthält keine Daten."
		endif
		if (!cnt(data(:,xcol)))
			throw "Die Spalte "+#xcol+" enthält keine Daten."
		endif
		{x0,B,x1} = zeroes data(:,ycol)-D -set x=data(:,xcol);
		is_nan(x1) ? B = 1/(B-x0)/2 : B = 1/(x1-x0);
		is_nan(B) ? B = 1/(max(data(:,xcol))-min(data(:,xcol)))/2 : 0;
		fit data(:,xcol:ycol) -with=A*sin(_2pi*B*x+C)+D params=[A,B,C=0,D] mask
		sinfit(fileindex,:) = A,B,C,D;
		return void
	endprocedure

	## Gedämpfter Sinusfit
	procedure $plugins~batchprocessing~dampedsinfit(fileindex, xcol = 1, ycol = 2) :: explicit private
		var A = (max(data(:,ycol))-min(data(:,ycol)))/2, B = 2/(max(data(:,xcol))-min(data(:,xcol))), C = nan, D, E = min(data(:,ycol))+A, x0 = nan, x1 = nan
		if (!cnt(data(:,ycol)))
			throw "Die Spalte "+#ycol+" enthält keine Daten."
		endif
		if (!cnt(data(:,xcol)))
			throw "Die Spalte "+#xcol+" enthält keine Daten."
		endif
		{x0,C,x1} = zeroes data(:,ycol)-E -set x=data(:,xcol);
		is_nan(x1) ? C = 1/(C-x0)/2 : C = 1/(x1-x0);
		is_nan(C) ? C = 1/(max(data(:,xcol))-min(data(:,xcol)))/2 : 0;
		fit data(:,xcol:ycol) -with=A*exp(-B*x)*sin(_2pi*C*x+D)+E params=[A,B,C,D=0,E] mask
		sinfit(fileindex,:) = A,B,C,D,E;
		return void
	endprocedure
	
	## Minimum/Maximum
	procedure $plugins~batchprocessing~minmax(fileindex) :: explicit private
		minmax(fileindex,1) = data -min;
		minmax(fileindex,2) = data -max;
		return void
	endprocedure
	
	procedure $plugins~batchprocessing~batch(directory, filescheme, evalcommand) :: explicit private
		## Variablen initialisieren
		var nStrings, sIndex
		str sDirectory = to_string(directory), sFileScheme = to_string(filescheme), sEvalCommand = to_string(evalcommand)
		
		## Stringindex ggf. prüfen
		if (!string())
			sIndex = 0
		else
			sIndex = cnt(string(:))
		endif
		
		## Eingaben prüfen
		if (!strlen(sDirectory))
			throw "Es wurde kein Dateiverzeichnis angegeben, auf welches das Batch-Processing angewendet werden soll."
		endif
		if (!strlen(sFileScheme) || (!strfnd("*",sFileScheme) && !strfnd("?",sFileScheme)))
			throw "Das Dateischema, welches für Batch-Processing notwendig ist, wurde nicht angegeben oder enthält keine Platzhalter."
		endif
		if (char(sDirectory,strlen(sDirectory)) != "/")
			sDirectory += "/"
		endif
		if (!findfile(sDirectory + sFileScheme))
			throw "Es wurden am angegebenen Ort keine Dateien gefunden, auf die das Dateischema zutrifft."
		endif
		if (!strlen(sEvalCommand))
			throw "Es wurde kein Ausdruck oder Kommando für die Auswertung angegeben."
		endif
		
		## Dateiliste bekommen
		string() = getfilelist(sDirectory + sFileScheme);
		
		## Ausgabe der verarbeiteten Dateien
		hline
		"BATCH-PROCESSOR" -print
		hline
		"Es wurden " + #(cnt(string(:))-sIndex) + " Dateien in \"" + sDirectory + "\" gefunden, auf die das angegebene Schema \""+sFileScheme+"\" zutrifft:" -print
		string(sIndex+1:) -print
		hline
		"Auswertung wird durchgeführt. Bitte einen Moment Geduld ..." -print
		nStrings = cnt(string(:))-sIndex;
		progress 0 -set type="   <bar> (<Val> %)"
		## Batch-Processing
		for (fIndex = 1:nStrings)
			data -load=sDirectory+string(fIndex+sIndex) ignore keepdim
			to_cmd(sEvalCommand)
			string(fIndex+sIndex) = ""
			progress fIndex -set last=nStrings type="   <bar> (<Val> %)"
		endfor -mask
		
		## Speicher leeren
		data -clear ignore
		return void
	endprocedure
	
	<helpindex>
		<article id="batch">
			<title string="Batch-Processor" idxkey="batch" />
			<keywords>
				<keyword>batch</keyword>
				<keyword>automat</keyword>
				<keyword>dateien</keyword>
			</keywords>
		</article>	
	</helpindex>
	
	<helpfile>
		<article id="batch">
			<title string="Batch-Processor" />
			Dieses Plugin ermöglicht es, viele Dateien, die nach einem bestimmten Schema benannt sind, automatisiert zu analysieren oder anderweitig zu modifizieren. Dazu müssen die entsprechenden Dateien sich alle in einem einzigen Ordner befinden.
			Das Kommando <code>batch</code> muss mit drei Parametern versehen werden: <code>dir</code>, <code>command</code> und <code>scheme</code>.
			<list>
				<item node="-dir=PFAD">PFAD gibt den Dateipfad zum Ordner an, in welchem die Dateien sich befinden</item>
				<item node="-command=EXPR">Hiermit ist der Ausdruck EXPR anzugeben, der zur Auswertung der Dateien verwendet werden soll. Es können übliche Ausdrücke oder auch Prozeduren (Prozeduren sollten auf jeden Fall in Anführungszeichen übergeben werden) verwendet werden. Das Kommando <code>batch</code> bietet die zwei Zählvariablen <code>fIndex</code> und <code>sIndex</code>, die die Nummer der Datei (fIndex) bzw. die Position des Dateinamens in<code>string()</code> (sIndex+fIndex) enthalten. Diese Variablen können der Auswerteprozedur übergeben werden, so dass sie in die Auswertung mit einfließen können. Es stehen auch vordefinierte Auswerteroutinen zur Verfügung (s.u.).</item>
				<item node="-scheme=SCHEMA">Als SCHEMA muss das Schema angegeben werden, nach welchem die Dateien benannt sind. Es muss mindestens ein <code>*</code> oder ein <code>?</code> in dem Schema enthalten sein.</item>
			</list>
			Dieses Plugin bietet die folgenden vordefinierten Auswerteroutinen (Bei den Anpassungen wird die erste Spalte als x- und die zweite als y-Werte interpretiert, falls nichts anderes angegeben ist.):
			<list>
				<item node="minmax">Berechnet globales Minimum/Maximum</item>
				<item node="sinfit">Passt einen Sinus an die Datenreihen an: Amplitude*sin(_2pi*Frequenz*x+Phase)+Offset</item>
				<item node="sinfit(x,y)">Passt einen Sinus an die Datenreihen an, wobei x und y die entsprechenden x- und y-Spalten bezeichnet</item>
				<item node="dampedsinfit">Passt einen gedämpften Sinus an die Datenreihen an: Amplitude*exp(-Zeitkonst*x)*sin(_2pi*Frequenz*x+Phase)+Offset</item>
				<item node="dampedsinfit(x,y)">Passt einen gedämpften Sinus an die Datenreihen an, wobei x und y die entsprechenden x- und y-Spalten bezeichnet</item>
			</list>
			HINWEIS: Dateien werden stets vollständig (also mit Leerspalten) geladen. Dies sollte beim Schreiben des Kommandoausdrucks beachtet werden.
			<example desc="Automatisches Bestimmen der Amplitude mehrer Dateien und Speichern des Ergebnisses in cache():">
				batch -dir="<loadpath>/Messdaten" scheme="*.dat" command="cache(fIndex,1) = (max(data(:,4))-min(data(:,4)))/2"
			</example>
		</article>
	</helpfile>
<endinstall>

#* Ende des Scripts
 * NumeRe: Framework für Numerische Rechnungen | Freie numerische Software unter der GNU GPL v3
 * https://sites.google.com/site/numereframework
 *#
